# LeetCode

# 1. 数组

## 1. 数组理论

数组是存放在连续内存空间上的相同类型数据的集合。

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

**数组的元素是不能删的，只能覆盖。**

**二维数组在内存的空间地址是连续的么？**

- 不同编程语言的内存管理是不一样的。

## 2. 704 二分查找

### 1. 题目要求提示

1. **有序数组**
2. **数组中无重复元素**

### 2. 区间定义

1. **区间的定义就是不变量**。
2. **循环不变量**
3. 左闭右闭即[left, right]
4. 左闭右开即[left, right)

## 3. 209 滑动窗口

1. 一个for循环，j为终止位置，如何移动起始位置
2. for 嵌套while

## 4. 59 螺旋矩阵

1. 模拟转圈过程
2. 循环不变量
3. 左闭右开，只处理第一个节点，不包含最后一个节点
4. 转多少圈（n/2）
5. 判断是否是奇数
6. 创建两个变量，startx和starty，创建一个变量控制终止位置，还有每次i和j循环滚动变化的值

# 2. 链表

## 1. 链表基础

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。链表的头结点也就是head。

### 1. 链表类型

1. 单链表
2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
3. 循环链表：链表首尾相连。

### 2. 链表存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

### 3. 链表定义

### 4. 链表操作

#### 1.删除节点

只要将C节点的next指针 指向E节点就可以了。

#### 2. 添加节点

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

### 5. 性能分析

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

## 2. 虚拟头节点

不用特别针对头节点进行特别判断

## 3. 142 环形链表 双指针

1. 快慢指针
2. 快走2，慢走1
3. 慢指针进入时两指针相差节点数一定是小于一圈的，相对速度又是1，所以一圈内肯定被追上

# 3. 哈希表

## 1. 哈希表理论

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。 

### 1. 哈希表

**一般哈希表都是用来快速判断一个元素是否出现集合里。**

哈希表就是一个数组。

### 2. 哈希函数

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

### 3. 哈希碰撞

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

### 4. 拉链法

发生冲突的元素都被存储在链表中。 

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

### 5. 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。

### 6. 常见的三种哈希结构

- 数组
- set （集合）
- map(映射)

### 7. 总结

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。但是哈希法也是。

## 2. 202 快乐数

set重复 

# Git issue tips

```
Git: fatal: bad object refs/remotes/origin/main 2

git remote prune origin
```

